Architectural Summary – Codebase Chunk 3 (Backend OrderService domain models, repositories and data access; Client data access; Config and tests)

Scope of this chunk
- Backend domain models for Quote and Shipment.
- Repository interfaces and two storage implementations: in-memory (mock) and MongoDB.
- RepositoryFactory that selects storage kind (“memory” vs “mongodb”).
- MongoDB document models and a MongoOperations wrapper with retry/telemetry.
- Client static web (WinJS) that consumes REST endpoints exposed by controllers (controllers not in this chunk, but client/tests reveal API contracts).
- Spring configuration properties and ApplicationInsights config.
- Extensive tests that clarify behavior, endpoints, and invariants.

Key components and responsibilities
- Domain models (POJOs)
  - Quote: Represents a quote sent to clients.
    - Fields: quoteId, validUntil, customerName, dealerName, List<QuoteItemInfo> quoteItems, totalCost, discount, city, postalCode, state.
    - Methods: validate (checks dealerName, customerName), addQuoteItem, getters/setters, equals/hashCode (see risks section).
  - QuoteItemInfo: Line item with skuNumber and amount. Comparable by skuNumber; equals/hashCode provided.
  - ShipmentEventInfo: Shipment event with date and comments; validate ensures comments present.
  - ShipmentRecord: Consolidated shipment per orderId.
    - Fields: orderId, deliveryDate, events (List<ShipmentEventInfo>), deliveryAddress, contactName, primaryContactPhone, alternateContactPhone.
    - Methods: addEvent, validate (orderId, deliveryDate, deliveryAddress, contact info).

- Repository interfaces (Repository pattern)
  - CatalogItemsRepository
    - getCatalogItems()
    - getCatalogItem(sku)
    - upsertCatalogItem(sku, CatalogItem, eTag)
    - removeCatalogItem(sku, eTag)
  - DealersRepository
    - getDealers()
    - getDealer(name)
    - upsertDealer(DealerInfo, eTag)
    - removeDealer(name, eTag)
  - QuoteRepository
    - getQuote(id)
    - getQuotesByCustomerName(customerName)
    - getQuoteIdsByDealerName(dealerName)
    - createQuote(Quote)
    - updateQuote(id, Quote, eTag)
    - removeQuote(id, eTag)
  - OrderRepository
    - hasOrder(id)
    - getOrder(id)
    - getOrderByQuoteId(quoteId)
    - getOrdersByStatus(status)
    - getOrdersByDealerName(dealerName, status)
    - createOrder(fromQuoteId)
    - updateOrder(id, Order, eTag)
    - updateOrder(id, OrderUpdateInfo, eTag)
    - removeOrder(id, eTag)
  - ShipmentRepository
    - getShipments(OrderStatus status)
    - getShipmentById(orderId)
    - createShipment(ShipmentRecord)
    - addEvent(orderId, ShipmentEventInfo)
    - updateShipment(ShipmentRecord)
    - removeShipment(orderId, eTag)

- Storage selector (Abstract factory)
  - RepositoryFactory
    - Static factory providing concrete repositories based on ordering.storage (“memory” or “mongodb”).
    - Holds per-storage Repositories bundle (catalogItems, dealers, quotes, orders, shipments).
    - reset(storage) reinitializes repo instances and (re)wires dependencies across repos.

- In-memory repositories (for testing/dev)
  - MockCatalogItemsRepository: ArrayList-based; case-insensitive SKU comparisons; sample seed items.
  - MockDealersRepository: ArrayList-based; case-insensitive name comparisons.
  - MockQuoteRepository: ArrayList-based.
    - On create/update: ensures dealer exists via DealersRepository; auto-generates numeric quoteId if empty using Random; duplicate creates throw BadRequestException.
  - MockOrderRepository:
    - createOrder(fromQuoteId): Requires quote exists; prohibits duplicate order-per-quote (throws conflict); sets orderId = "order-{quoteId}", orderDate = today (DateFormat.SHORT), status = Created.
    - getOrdersByDealerName: Resolves quote per order to match dealerName.
    - updateOrder(OrderUpdateInfo): appends event and updates status.
  - MockShipmentRepository:
    - createShipment: Requires order exists and no existing shipment for order; adds ShipmentRecord.
    - getShipments(OrderStatus): If status != None, filters by the associated order’s status via OrderRepository.

- MongoDB repositories (Spring Data MongoDB via MongoTemplate)
  - MongoOperationsWithRetry (resilience + telemetry)
    - Wraps MongoOperations; for selected operations (findAll, findOne, find, exists, findAndRemove, insert, save, dropCollection) retries once if DataAccessResourceFailureException caused by SocketTimeoutException.
    - Sends Application Insights RemoteDependencyTelemetry with operation name (e.g., MongoDB.findOne) and duration/success.
  - MongoCatalogItemsRepository:
    - Collections: “catalog”.
    - findOne by skuNumber; save acts as upsert by setting existing id if found.
    - remove by skuNumber.
  - MongoDealersRepository:
    - Collections: “dealers”; unique indexed name.
    - upsert by name; save with existing id to update; remove by name.
  - MongoQuoteRepository:
    - Collections: “quotes”.
    - createQuote: validates/ensures dealer exists via DealersRepository; generates numeric quoteId if missing; rejects duplicates; inserts QuoteDetails.
    - getQuotesByCustomerName: currently loads all quotes and filters in memory (not server-side filter).
    - getQuoteIdsByDealerName: server-side equality filter on dealerName, returns quoteId list.
    - update stores new QuoteDetails preserving id.
    - remove by quoteId.
  - MongoOrderRepository:
    - Collections: “orders”.
    - hasOrder/getOrder/getOrderByQuoteId via indexed fields.
    - getOrdersByStatus: either all or filter by status.
    - getOrdersByDealerName: obtains quote ids by dealer via QuoteRepository, then queries orders where quoteId in quotesIds; optional status filter.
    - createOrder: requires existing quote; enforces 1 order per quote; sets orderId/orderDate/status; inserts OrderDetails.
    - update by replacing document by id; update(OrderUpdateInfo) adds event and updates status before save.
    - remove by orderId.
  - MongoShipmentRepository:
    - Collections: “shipments”.
    - getShipments(OrderStatus): obtains orders by status via OrderRepository, then queries shipments where orderId in collected list.
    - getShipmentById: by orderId.
    - createShipment: requires order exists; rejects duplicate shipment record per order; inserts ShipmentDetails.
    - addEvent: load ShipmentDetails, append event (via converting to ShipmentRecord), re-save.
    - updateShipment: replace content preserving id.
    - remove by orderId.

MongoDB document models (schema)
- CatalogItem (collection “catalog”)
  - id (Mongo _id)
  - skuNumber (Indexed)
  - description (String)
  - price (double)
  - inventory (int)
  - leadTime (int)
  - Mapping behavior: toCatalogItem sets leadTime=0 if inventory>0; otherwise uses stored leadTime.

- Dealer (collection “dealers”)
  - id
  - name (Indexed)
  - contact (String)
  - address (String)
  - email (String)
  - phone (String)

- QuoteDetails (collection “quotes”)
  - id
  - quoteId (Indexed)
  - validUntil (String)
  - customerName (String)
  - dealerName (Indexed)
  - quoteItems (array of QuoteItemInfo objects with skuNumber, amount)
  - totalCost (double)
  - discount (double)
  - city (String)
  - postalCode (String)
  - state (String)

- OrderDetails (collection “orders”)
  - id
  - orderId (Indexed)
  - quoteId (Indexed)
  - orderDate (String)
  - status (Indexed, enum OrderStatus)
  - events (array of OrderEventInfo)

- ShipmentDetails (collection “shipments”)
  - id
  - orderId (Indexed)
  - events (array of ShipmentEventInfo)
  - deliveryAddress (DeliveryAddress embedded)
  - contactName (String)
  - primaryContactPhone (PhoneInfo embedded)
  - alternateContactPhone (PhoneInfo embedded)
  - Note: deliveryDate exists in ShipmentRecord but is not persisted in ShipmentDetails (data loss risk).

Service dependencies and communication patterns
- Internal repository dependencies:
  - QuoteRepository -> DealersRepository (ensures dealer exists on quote create/update).
  - OrderRepository -> QuoteRepository (order creation and dealer-filtered queries).
  - ShipmentRepository -> OrderRepository (creation validation and status-based shipment retrieval).
- RepositoryFactory wires these dependencies for both in-memory and MongoDB implementations.
- Cross-component coupling: repositories call other repositories directly (not via events or messaging).
- Persistence layer uses Spring Data MongoTemplate via a custom wrapper adding retry/telemetry.

External interfaces (REST API endpoints inferred from client and tests)
Note: Controllers are not in this chunk; endpoints derived from tests and src/Clients/Web/js/data.js.
- Catalog
  - GET /catalog → List<CatalogItem>
  - GET /catalog/{sku} → CatalogItem
  - POST /catalog → create catalog item (body: CatalogItem); 201 Created
  - PUT /catalog/{sku} → upsert/update; 200 OK if updated, 404 if SKU not found on upsert path (test indicates upsert returns 404 before create)
  - DELETE /catalog/{sku} → 204 No Content if removed
- Dealers
  - GET /dealers → List<DealerInfo>
  - GET /dealers/{name} → DealerInfo
  - POST /dealers → create dealer; 201 Created
  - PUT /dealers/{name} → update; 200 OK; 404 Not Found if dealer missing; 400 on invalid payload
  - DELETE /dealers/{name} → 204 No Content if removed
- Quotes
  - GET /quotes?name={searchTerm} → List<Quote> filtered by customerName contains (case-insensitive)
  - GET /quotes/{id} → Quote
  - POST /quotes → create quote; 201 Created; auto-generates numeric id if blank/empty; 400 Bad Request on duplicate id
  - PUT /quotes/{id} → update; 200 OK; 404 Not Found if missing
  - DELETE /quotes/{id} → 204 No Content
- Orders
  - GET /orders?dealer={dealerName}&status={OrderStatus} → List<Order>
    - dealer optional/empty; status optional with default “None” (no filter).
  - GET /orders/{id} → Order
  - POST /orders?fromQuote={quoteId} or body { fromQuote: quoteId } → create; 201 Created; 409 Conflict if already exists for quote
  - PUT /orders/{id} → replace/update full order; 200 OK
  - PUT /orders/{id}/status → body { status: OrderStatus, eventInfo: OrderEventInfo } → 200 OK; adds event and updates status
  - POST /orders/{id}/events → body: OrderEventInfo → 201 Created; server sets event date to today in tests
  - DELETE /orders/{id} → (not fully implemented in mocks; expected 204)
- Shipments
  - GET /shipments[?status={OrderStatus}] → List<ShipmentRecord>; client calls without param; controllers in tests accept OrderStatus; backend filters by associated order’s status.
  - GET /shipments/{orderId} → ShipmentRecord
  - POST /shipments → create ShipmentRecord; 400 Bad Request if order doesn’t exist; 201 Created
  - PUT /shipments/{orderId} → update/replace; 200 OK
  - POST /shipments/{orderId}/events → add ShipmentEventInfo (present in repositories; client doesn’t use; tests call controller.addEvent)
  - DELETE /shipments/{orderId} → 204 No Content (mock impl returns false; mongo impl supports remove)

Key business logic and algorithms
- Quote creation:
  - Ensures dealer exists; creates dealer entry if missing.
  - Generates numeric quoteId if empty/null: Random & 0x7FFFFFFF (Mongo and mock).
  - Duplicate quoteId on create → BadRequestException.
- Quote equality:
  - Compares all fields; compares quoteItems after sorting by skuNumber; see risks: validUntil comparison bug.
- Order creation:
  - Requires existing Quote by quoteId.
  - Enforces one order per quote; rejects duplicate with ConflictingRequestException.
  - Sets orderId = "order-{quoteId}", orderDate = DateFormat.SHORT(today), status Created.
- Order updates:
  - Full update replaces record.
  - Status update endpoint adds an event and updates status in a single operation.
- Orders by dealer:
  - In-memory: retrieves quote for each order to filter by dealer name (case-insensitive).
  - Mongo: uses QuoteRepository.getQuoteIdsByDealerName to build query criteria (quoteId in ...); optional status filter.
- Shipment creation:
  - Requires associated order exists; one shipment per order; rejects duplicates.
- Shipment retrieval by status:
  - Filters shipments by status of associated order (mimics join via orderIds in Mongo).
- Catalog lead time computation:
  - Mapping adjusts leadTime to 0 when inventory > 0 upon read from Mongo document.

Configuration and deployment details
- Spring Boot properties (src/main/resources/application.properties)
  - server.port: 8080
  - management.port: 8081 (Actuator)
  - management.address: 127.0.0.1
  - ordering.storage: mongodb (selects RepositoryFactory backend)
  - ordering.pingMessage / ordering.validationMessage (service metadata)
  - mongodb.host: localhost
  - mongodb.database: ordering
- Application Insights (ApplicationInsights.xml)
  - Web modules enabled; DeveloperMode true; InstrumentationKey empty (to be configured for environments).
- Test configuration (src/test/resources/application.properties; TestOrderingConfiguration)
  - ordering.storage: memory by default for unit tests.
  - mongodb.host: localhost; mongodb.database: orderingtest (integration tests)
  - TestOrderingConfiguration creates MongoTemplate; honors MONGO_PORT env var (e.g., Docker) to derive host; defines TelemetryClient bean; resets RepositoryFactory with chosen storage.

Frameworks, libraries, patterns
- Java/Spring
  - Spring Boot (auto-configuration, Actuator ports)
  - Spring Data MongoDB (MongoTemplate, Query/Criteria)
  - Repository pattern for domain data access.
  - Abstract Factory (RepositoryFactory) to select storage backend.
  - MongoOperationsWithRetry: retry pattern on transient network failures; integrates Application Insights for telemetry.
- Telemetry
  - Microsoft Application Insights SDK for Java; RemoteDependencyTelemetry for Mongo operations.
- Client
  - Static web client (WinJS) packaged as WAR; orchestrates REST calls and basic client-side state (Binding.List).
  - Client-level data orchestration: composes Orders with their Quote (enriches order with __quote), manages status changes and event additions.

Service dependencies (for microservice decomposition considerations)
- Current module conflates catalog, dealers, quotes, orders, and shipments in a single deployable (“OrderService”).
- Logical subdomains and direct dependencies:
  - CatalogService (catalog items) – independent.
  - DealerService (dealers) – independent.
  - QuoteService – depends on DealerService (dealer existence).
  - OrderService – depends on QuoteService (quote existence; join to filter by dealer).
  - ShipmentService – depends on OrderService (order existence; filtering shipments by order status).
- Tight coupling exists via direct repository calls across subdomains (e.g., OrderRepository → QuoteRepository; ShipmentRepository → OrderRepository; QuoteRepository → DealersRepository). In a microservice split, these would become inter-service calls or asynchronous events.

Data models (summarized)
- Quote: {
  quoteId: String (key), validUntil: String, customerName: String, dealerName: String,
  quoteItems: [{skuNumber: String, amount: double}],
  totalCost: double, discount: double, city: String, postalCode: String, state: String
}
- Order: {
  orderId: String (key), quoteId: String (FK), orderDate: String, status: OrderStatus,
  events: [{date: String, comments: String}]
}
- ShipmentRecord: {
  orderId: String (key/FK), deliveryDate: String, events: [{date, comments}],
  deliveryAddress: {street, city, state, postalCode, specialInstructions?},
  contactName: String, primaryContactPhone: {phoneNumber, kind}, alternateContactPhone: {phoneNumber, kind}
}
- CatalogItem: { skuNumber: String (key), description: String, price: double, inventory: int, leadTime: int }
- DealerInfo: { name: String (key), contact, address, email, phone }

Client-side REST usage (js/data.js)
- Uses XMLHttpRequest via WinJS.xhr with JSON bodies.
- Endpoints match the API list above.
- Implements client-side joining and state flags (__new), and supports incremental event posting on orders.

Notable constraints and risks (technical debt to consider in microservice decomposition)
- Equality bug in Quote.equals: validUntil comparison condition is inverted; could produce false negatives/positives in logical equality checks.
- Quote.equals assumes quoteItems non-null before size() calls; potential NPE if null.
- ShipmentDetails does not persist deliveryDate; data loss between API and persistence.
- eTag parameters present in repository interfaces but not implemented/enforced; no optimistic concurrency on writes.
- MongoQuoteRepository.getQuotesByCustomerName loads all quotes and filters in memory; not scalable.
- Direct synchronous dependencies across repositories; in a microservice architecture, these would require API calls or event-driven integration.
- OrderId convention “order-{quoteId}” hardwired; may conflict with future ID schemes; relies on uniqueness of quoteId.
- Error handling for Mongo retries limited to SocketTimeoutException; broader transient failure handling may be needed.
- Controllers not shown here; behavior inferred from tests; ensure alignment when decomposing.

Testing and CI implications
- Unit tests use in-memory repositories; integration tests switch to MongoDB via RepositoryFactory.reset("mongodb") and Spring Test context (ConfigurationRule).
- Tests verify controller/API behaviors (status codes, header locations), data invariants (one order per quote), and cross-entity queries (orders by dealer).

Deployment and operations
- Runs as Spring Boot app with HTTP port 8080 and management 8081.
- RepositoryFactory initialized with ordering.storage property; production properties indicate mongodb.
- Application Insights configured in developer mode; instrumentation key must be supplied for telemetry in production.

Microservice decomposition guidance (based on this chunk)
- Candidate services:
  - Catalog Service: CRUD on catalog items.
  - Dealer Service: CRUD on dealers.
  - Quote Service: CRUD on quotes; depends on Dealer Service (synchronous API or event to validate/create dealer on demand).
  - Order Service: CRUD on orders; depends on Quote Service (validate existing quote; possibly get dealer info to support queries).
  - Shipment Service: CRUD on shipments; depends on Order Service (validate order exists; filter by order status).
- Cross-service interactions to replace repository calls:
  - QuoteService: on create/update, check dealer via Dealers API; or decouple and require existing dealerId.
  - OrderService: on create, check quote exists via Quotes API; for “orders by dealer”, either:
    - include dealerName/Id denormalized on Order at creation (event from QuoteService) to avoid cross-service joins, or
    - perform composite query via QuoteService to get quoteIds for dealer first (current approach).
  - ShipmentService: for getShipments by status, denormalize order status into shipment or query OrderService; consider eventual consistency with events.
- Data denormalization would reduce cross-service synchronous calls and enable more performant queries.

This summary captures the core data models, repository contracts, storage implementations, internal dependencies, observed API surface, and configuration behaviors necessary to plan and execute microservice decomposition for this portion of the codebase.