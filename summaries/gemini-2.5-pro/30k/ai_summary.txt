Of course. Here is a single, comprehensive architectural summary created by merging the detailed information from all six provided chunks. The summary is structured to eliminate redundancy while preserving all unique details for microservice decomposition analysis.

***

## Comprehensive Architectural Summary: Parts Unlimited MRP System

This document provides a consolidated architectural overview of the Parts Unlimited MRP (Manufacturing Resource Planning) application. It merges findings from a multi-part codebase analysis to create a single, detailed summary suitable for guiding a microservice decomposition effort.

### 1. Overall System Architecture

The Parts Unlimited MRP system is a Java-based application designed as a classic **three-tier architecture**. It follows a coarse-grained, service-oriented design and is composed of three primary, distinct components:

1.  **Frontend Service**: A static, client-side Single Page Application (SPA) that provides the user interface.
2.  **Order Service**: The core backend Java service containing all primary business logic and exposing a REST API.
3.  **Integration Service**: A supporting backend Java service that acts as an integration bridge to an external system, communicating asynchronously via message queues.

The system utilizes a monolithic **MongoDB** database, which is shared by both the Order and Integration services for data persistence. The codebase is rich with assets for **Infrastructure as Code (IaC)** and automated deployment, targeting both virtual machines (primarily on **Azure Stack**) and containerized environments using **Docker**.

---

### 2. Application Components

#### 2.1. Frontend Service (`Clients/Web`)

The Frontend Service is a feature-rich SPA responsible for the entire user experience.

*   **Responsibilities**: Provides the UI for managing the entire lifecycle of business entities: Catalog, Dealers, Quotes, Orders, and Deliveries (referred to as Shipments in the backend).
*   **Architectural Style & Patterns**:
    *   **Single Page Application (SPA)**: The application loads a single shell (`index.html`), and views are dynamically loaded into a container element without full page reloads, managed by a `PageControlNavigator`.
    *   **Master-Detail UI**: The dominant UI pattern, featuring a list view of items on the left and a detailed form view for the selected item on the right.
*   **Technology Stack**:
    *   **Core**: HTML5, CSS3, vanilla JavaScript.
    *   **Framework**: **Microsoft WinJS** is used extensively for application lifecycle, navigation, data binding (including a custom two-way binding implementation), and UI controls (ListView, ContentDialog).
    *   **Libraries**:
        *   **Date.js**: For advanced date/time parsing and manipulation.
        *   **Google Maps Places API**: For address autocompletion in forms.
*   **Consumed API & Communication**:
    *   Communicates exclusively with the `OrderService` via RESTful HTTP calls.
    *   The `js/data.js` file serves as a client-side data access layer, abstracting all API communication.
    *   All API requests are sent with `Pragma: no-cache` and `Cache-Control: no-cache` headers to prevent caching.
    *   The backend base URL is configured in `js/serverconfig.js` as `http://{window.location.hostname}:8080`, coupling the client to a backend running on the same host.
*   **Key Business Logic & Workflow**:
    *   The UI is structured around distinct business domains: Catalog, Dealers, Quotes, Orders, and Deliveries.
    *   It implements the core business workflow: a **Quote** is created, then converted into an **Order**, which is then used to create a **Delivery**. The UI repurposes "Edit" buttons to initiate these state transitions.
    *   Client-side data models mirror the backend entities and are made observable using `WinJS.Binding`.
    *   Complex views (like the Deliveries page) aggregate data by making multiple API calls and joining the results on the client side (e.g., fetching a delivery, its associated order, and the original quote).
*   **Deployment**:
    *   Built using **Gradle** into a `mrp.war` file.
    *   Deployed on an **Apache Tomcat** web server (versions 7 or 8).

#### 2.2. Order Service (`Backend/OrderService`)

The Order Service is the monolithic backend and system of record for the entire application.

*   **Responsibilities**: Manages the complete lifecycle of catalog items, dealers, quotes, orders, and shipments. It exposes a comprehensive REST API for the frontend and handles all data persistence.
*   **Architectural Style & Patterns**:
    *   **Layered Architecture**: A clear separation between the API (Controllers), Business Logic, and Data Access (Repositories) layers.
    *   **RESTful Service**: Exposes business logic through a resource-oriented HTTP API.
    *   **Repository Pattern**: Data persistence is abstracted via repository interfaces.
    *   **Factory Pattern**: A `RepositoryFactory` class dynamically provides either mock (in-memory) or MongoDB repository implementations based on a configuration setting (`ordering.storage`).
    *   **Decorator Pattern**: The `MongoOperationsWithRetry` class wraps the standard `MongoTemplate` to add retry logic and Application Insights telemetry for database calls.
*   **Technology Stack**:
    *   **Core**: Java 8, Spring Boot, Spring MVC, Spring Data MongoDB.
    *   **Build**: Gradle.
    *   **Monitoring**: Microsoft Application Insights for telemetry and monitoring.
*   **API Endpoints**: The service exposes a full suite of REST endpoints for CRUD and business operations.
    *   `/api/ping`: Health check.
    *   `/api/catalog`: CRUD for `CatalogItem`.
    *   `/api/dealers`: CRUD for `DealerInfo`. An intentional performance bottleneck exists in the `GET /dealers` endpoint, which executes 100,000 DB queries.
    *   `/api/quotes`: CRUD for `Quote`, with query-by-name support.
    *   `/api/orders`:
        *   `POST /?fromQuote={quoteId}`: Creates an `Order` from a `Quote`.
        *   `GET /?dealer={dealerName}&status={status}`: Filters orders.
        *   `GET, PUT, DELETE /{orderId}`: Manages a specific order.
        *   `POST /{orderId}/events`: Adds an event to an order's history.
        *   `PUT /{orderId}/status`: Updates an order's status and adds a corresponding event.
    *   `/api/shipments`:
        *   CRUD for `ShipmentRecord`.
        *   `POST, GET, PUT /{orderId}`: Manages a shipment using its associated `orderId`.
        *   `POST /{orderId}/events`: Adds a shipping event.
        *   `GET /deliveries`: An aggregate endpoint that manually "joins" data from `shipments`, `orders`, and `quotes` collections at the application layer to provide a consolidated view.
*   **Key Business Logic & Internal Dependencies**:
    *   **Quote-to-Order Workflow**: An order can only be created from a valid, existing quote that has not already been converted. This logic is encapsulated in the API.
    *   **Data Aggregation**: The `GET /shipments/deliveries` endpoint demonstrates tight coupling between the Shipment, Order, and Quote domains, performing sequential queries across three repositories to build its response.
    *   **Repository Dependencies**: Concrete repository implementations have dependencies on each other (e.g., `MongoOrderRepository` depends on `QuoteRepository` for validation; `MongoShipmentRepository` depends on `OrderRepository` for status queries).
*   **Deployment**:
    *   Built into a standalone executable fat JAR (`ordering-service-0.1.0.jar`).
    *   Runs directly via `java -jar`.

#### 2.3. Integration Service (`Backend/IntegrationService`)

This is a headless background service that synchronizes data between the MRP system and an external "Parts Unlimited Website".

*   **Responsibilities**: Acts as an integration bridge, processing order and product updates asynchronously.
*   **Architectural Style & Patterns**:
    *   **Anti-Corruption Layer (ACL)**: Translates data between the external website's format and the internal MRP system's format. It maintains two distinct sets of models (`models/website` and `models/mrp`).
    *   **Queue-Based Decoupling**: Uses Azure Storage Queues to asynchronously buffer communication, increasing system resilience.
    *   **Scheduled Polling**: Uses Spring's `@Scheduled` annotation to periodically poll queues and trigger data synchronization tasks.
*   **Technology Stack**: Java 8, Spring Boot, Gradle.
*   **Communication & Dependencies**:
    *   **Inbound (Asynchronous)**: Consumes `OrderMessage` objects from an Azure Storage Queue (`website.orders.new`). It has **no inbound API endpoints**.
    *   **Outbound (Synchronous)**: Makes REST API calls to the `OrderService` (via `MrpConnectService`) to create quotes, orders, and shipments.
    *   **Outbound (Asynchronous)**: Produces `ProductMessage` objects (containing inventory updates) to another Azure Storage Queue (`website.products.update`).
*   **Key Business Logic**:
    *   **`CreateOrderProcessTask`**: A scheduled job that reads from the orders queue and orchestrates a sequence of REST calls to the `OrderService`: `POST /quotes` -> `POST /orders` -> `POST /shipments`.
    *   **`UpdateProductProcessTask`**: A scheduled job that calls `GET /catalog` on the `OrderService`, transforms the data, and pushes it to the product update queue.
*   **Deployment**:
    *   Built into a standalone executable JAR (`integration-service-0.1.0.jar`).
    *   Its deployment is managed separately and is not part of the primary `deploy_mrp_app.sh` script, suggesting it is an optional component.

---

### 3. Data Persistence (MongoDB)

A single MongoDB instance serves as the data store for the backend services.

*   **Database Name**: `ordering` (for production/development), `orderingtest` (for integration tests).
*   **Schema**: Document-based, implicitly defined by the Java models. Initial data is seeded via the `deploy/MongoRecords.js` script during deployment.
*   **Collections & Data Models**:
    *   **`catalog`**: Stores product information. Maps to `CatalogItem`.
        *   `skuNumber` (string, indexed), `description`, `price`, `inventory`, `leadTime`.
    *   **`dealers`**: Stores dealer information. Maps to `Dealer`.
        *   `name` (string, indexed), `address`, `email`, `phone`.
    *   **`quotes`**: Stores customer quotes. Maps to `QuoteDetails`.
        *   `quoteId` (string, indexed), `validUntil`, `customerName`, `dealerName` (indexed), `totalCost`, `quoteItems` (array of objects).
    *   **`orders`**: Stores orders created from quotes. Maps to `OrderDetails`.
        *   `orderId` (string, indexed), `quoteId` (indexed), `orderDate`, `status` (indexed enum), `events` (array).
    *   **`shipments`**: Stores shipping details. Maps to `ShipmentDetails`.
        *   `orderId` (string, indexed), `deliveryDate`, `contactName`, `deliveryAddress` (object), `events` (array).

---

### 4. Configuration, Deployment, and Operations

The project has a mature and flexible operational design with a strong emphasis on automation.

*   **Build System**: **Gradle** is used consistently across all projects.
*   **CI/CD**: A `.travis.yml` file defines a continuous integration pipeline. Jenkins templates are also provided, indicating CI/CD is a core workflow.
*   **Configuration**: Application settings are managed in `application.properties` files. Key properties include `server.port`, `mongodb.*` connection details, and the custom `ordering.storage` flag to switch data access layers.
*   **Containerization (Docker)**:
    *   Dockerfiles are provided for each component: `Database` (mongo), `Order` (openjdk:8-jre), and `Clients` (tomcat:7-jre8).
    *   Simple shell scripts (`BuildAndRun.sh`) orchestrate the local container environment, using Docker's legacy `--link` feature for service discovery.
*   **Infrastructure as Code (IaC)**:
    *   **Target Environment**: Primarily **Azure and Azure Stack**.
    *   **Provisioning**: **Azure Resource Manager (ARM) templates** are used to provision complete environments, including VMs, networks, and security groups.
    *   **Configuration Management**: Scripts for **Chef** (`default.rb`), **Puppet** (`init.pp`), and **Ansible** (`.yml`) are included to automate the configuration of provisioned VMs (installing Java, Tomcat, MongoDB, and deploying the application artifacts).
*   **Network Configuration**:
    *   **`80/TCP`**: Frontend access (Docker host port, maps to 8080).
    *   **`9080/TCP`**: Frontend access (Tomcat port in VM deployments).
    *   **`8080/TCP`**: `OrderService` REST API port.
    *   **`27017/TCP`**: Standard MongoDB port.
    *   **`22/TCP`**: SSH access for VMs.

---

### 5. Summary for Microservice Decomposition Analysis

The existing architecture provides strong indicators and a solid foundation for decomposition into microservices.

*   **Clear Service Boundaries**: The application is already logically divided along clear business domain boundaries, visible in both the frontend UI modules and the backend API controllers: **Catalog**, **Dealers**, **Quotes**, **Orders**, and **Shipments/Deliveries**. These are strong candidates for separate microservices.
*   **Business Process Flow**: The UI and backend logic clearly define a core business workflow: **Quote → Order → Shipment**. Any microservice architecture must preserve this flow, likely through a choreographed sequence of API calls or an event-driven, orchestrated saga pattern.
*   **Data Coupling and Aggregation**: The analysis reveals significant data coupling that must be addressed.
    *   The **Orders** domain requires data from the **Quotes** domain.
    *   The **Shipments** domain requires data from both the **Orders** and **Quotes** domains.
    *   The `GET /shipments/deliveries` endpoint is a critical smell, performing application-side joins across three collections. This signals the need for a **Backend for Frontend (BFF)** or an **API Gateway** pattern to handle such data aggregation, preventing the client from becoming overly chatty or complex.
*   **Shared Dependencies**:
    *   **Catalog** is a shared resource consumed by the **Quotes** service (to add items to a quote). This makes it a prime candidate for a standalone, highly available service.
    *   **Dealers** are referenced by **Quotes**, suggesting a similar pattern.
*   **API Design**: The existing REST API of the `OrderService`, consumed by both the frontend and the `IntegrationService`, serves as an excellent blueprint for the contracts of the new, smaller microservices. The `data.js` abstraction in the client provides a good model for the API surface a BFF would need to expose.
*   **Integration Patterns**: The `IntegrationService` already demonstrates successful use of the **Anti-Corruption Layer** and **Queue-Based Decoupling** patterns. These are proven models that can be adopted for asynchronous communication between the new microservices to enhance resilience and autonomy.